import{R as l}from"./generator-wcUYG9Ml.js";var u=Object.defineProperty,d=Object.defineProperties,f=Object.getOwnPropertyDescriptors,n=Object.getOwnPropertySymbols,g=Object.prototype.hasOwnProperty,m=Object.prototype.propertyIsEnumerable,o=(t,s,e)=>s in t?u(t,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[s]=e,h=(t,s)=>{for(var e in s||(s={}))g.call(s,e)&&o(t,e,s[e]);if(n)for(var e of n(s))m.call(s,e)&&o(t,e,s[e]);return t},_=(t,s)=>d(t,f(s)),v=class{constructor(t,s=-1,e=!1){this.startTime=-1,this.duration=0,this.process="freeze",this.painted=this.listen,this.erased=this.listen,this.path=t,this.length=t.getTotalLength(),this.trace=this.clacInitTrace(s),this.path.style.strokeDasharray=`${this.length}px`,this.path.style.strokeDashoffset=`${this.length-this.trace}px`,e&&this.start()}done(){return this.process==="paint"&&this.trace>=this.length||this.process==="erase"&&this.trace<=0}clacInitTrace(t){return t===-1?this.length:t}update(){this.trace=Math.min(this.trace,this.length),this.trace=Math.max(this.trace,0);let t=this.length-this.trace;this.path.style.strokeDashoffset=`${t}px`}initStartTime(t){this.startTime===-1&&(this.startTime=t)}calcStep(t,s){if(this.duration===0)return this.length;const e=(t-s)/this.duration;return e>=1?this.length:this.length*e}_paint(t,s){this.initStartTime(t);const e=this.calcStep(t,s??this.startTime);this.trace+=e,this.update(),this.done()&&this.painted(),this._listen(t)}_erase(t,s){this.initStartTime(t);const e=this.calcStep(t,s??this.startTime);this.trace-=e,this.update(),this.done()&&this.erased(),this._listen(t)}_listen(t){requestAnimationFrame(s=>{switch(this.process){case"paint":this._paint(s,t);break;case"erase":this._erase(s,t);break;case"listen":this._listen(s);break}})}paint(t,s=this.trace){this.duration=t,this.process="paint",this.startTime=-1,this.trace=this.clacInitTrace(s)}erase(t,s=this.trace){this.duration=t,this.process="erase",this.startTime=-1,this.trace=this.clacInitTrace(s)}stop(){this.process="freeze",this.startTime=-1}listen(){this.process="listen",this.startTime=-1}start(){this.process==="freeze"&&(this.process="listen",this._listen())}onPainted(t){this.painted=()=>{this.listen(),t()}}onErased(t){this.erased=()=>{this.listen(),t()}}};_(h({},new l().defaultOptions),{disableMultiStroke:!0});var b={linecap:"round",zIndexOffset:0,color:"currentColor",strokeWidth:2,iterations:1,brackets:5,opacity:1,class:""};function c(t){return w(t.sets)}function w(t){const s=[];for(const e of t){let r="";for(const a of e.ops){const i=a.data;switch(a.op){case"move":r.trim()&&s.push(r.trim()),r=`M${i[0]} ${i[1]} `;break;case"bcurveTo":r+=`C${i[0]} ${i[1]}, ${i[2]} ${i[3]}, ${i[4]} ${i[5]} `;break;case"lineTo":r+=`L${i[0]} ${i[1]} `;break}}r.trim()&&s.push(r.trim())}return s}var p="http://www.w3.org/2000/svg",O=class{constructor(t,s,e){switch(this.pathLengths=[],this.pathsTotalLength=0,this.options=h(h({},b),e),this.target=t,this.rect=t.getBoundingClientRect(),typeof s=="function"&&(s=s(this.rect.width,this.rect.height)),typeof s){case"string":this.pathDatas=[s];break;case"object":Array.isArray(s)?this.pathDatas=s.map(r=>typeof r=="string"?[r]:c(r)).flat():this.pathDatas=c(s);break}this.cur=0,this.duration=1e3,this.svg=this.createSVG(),this.initTarget(),this.paths=this.cratePaths(),this.animators=this.createAnimators(),this.animators[this.cur].start()}createSVG(){const t=document.createElementNS(p,"svg");t.setAttribute("viewBox",`0 0 ${this.rect.width} ${this.rect.height}`),this.options.class.length&&t.setAttribute("class",this.options.class);const s=t.style;return s.zIndex=this.target.style.zIndex+this.options.zIndexOffset,s.overflow="visible",s.pointerEvents="none",s.position="absolute",s.top="0",s.left="0",t}createPath(t,s,e,r,a){const i=document.createElementNS(p,"path");return i.setAttribute("d",t),i.setAttribute("stroke",s),i.setAttribute("fill","none"),i.setAttribute("stroke-linecap",e),i.setAttribute("stroke-width",r.toString()),i.setAttribute("stroke-opacity",a.toString()),i}initTarget(){return this.target.style.setProperty("position","relative"),this.target.appendChild(this.svg),this.target}cratePaths(){const t=[];for(const s of this.pathDatas){const e=this.createPath(s,this.options.color,this.options.linecap,this.options.strokeWidth,this.options.opacity);t.push(e);const r=e.getTotalLength();this.pathLengths.push(r),this.pathsTotalLength+=r,this.svg.appendChild(e)}return t}durationOf(t){return this.duration*this.pathLengths[t]/this.pathsTotalLength}createAnimators(){const t=this.paths.map(s=>new v(s,0));for(let s=0;s<t.length;++s)s!==t.length-1&&t[s].onPainted(()=>{t[s].stop(),this.cur=s+1,t[this.cur].start(),t[this.cur].paint(this.durationOf(this.cur))}),s!==0&&t[s].onErased(()=>{t[s].stop(),this.cur=s-1,t[this.cur].start(),t[this.cur].erase(this.durationOf(this.cur))});return t}show(t=1e3){this.duration=t,this.animators[this.cur].paint(this.durationOf(this.cur))}stop(){this.animators[this.cur].listen()}hide(t=1e3){this.duration=t,this.animators[this.cur].erase(this.durationOf(this.cur))}remove(){this.animators.forEach(t=>t.stop()),this.target.removeChild(this.svg)}onShowed(t){this.animators[this.animators.length-1].onPainted(t)}onHidden(t){this.animators[0].onErased(t)}};export{O as default};
